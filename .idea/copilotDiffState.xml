<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# ☕ PoC - Explorando o Java 25 (e versões anteriores)&#10;&#10;Este repositório contém exemplos práticos explorando **novidades do Java 18 até o Java 25**.  &#10;A ideia é revisar recursos que surgiram nas versões recentes e experimentar, na prática, como utilizá-los em projetos do dia a dia.&#10;&#10;---&#10;&#10;##  Estrutura do Projeto&#10;&#10;- `jwebserver/` → Exemplo do servidor HTTP embutido no JDK 18+.&#10;- `virtualthread/` → **Virtual Threads** (Java 21+) - Threads leves para alta concorrência.&#10;- `sequencedcollections/` → **Sequenced Collections** (Java 21+) - Coleções com ordem garantida.&#10;- `unnamedvariablepatterns/` → **Unnamed Variables &amp; Patterns** (Java 22+) - Variáveis não nomeadas.&#10;- (em breve) `records/` → Exemplos com **Records**.&#10;- (em breve) `pattern-matching/` → Exemplos de **Pattern Matching**.&#10;- (em breve) `string-templates/` → Templates de String (Preview).&#10;- (em breve) `scoped-values/` → Scoped Values (substituindo ThreadLocal).&#10;&#10;Cada diretório terá exemplos isolados e um README explicando o recurso.&#10;&#10;---&#10;&#10;##  Pré-requisitos&#10;&#10;- **Java 25+** (recomendado instalar o JDK 25 LTS ou superior).&#10;- Maven ou Gradle (dependendo do exemplo).&#10;- Git para clonar o repositório.&#10;&#10;---&#10;&#10;## ️ Rodando o `jwebserver`&#10;&#10;Entre no diretório `jwebserver` e rode:&#10;&#10;```bash&#10;# Inicia um servidor HTTP na porta 8000&#10;jwebserver --port 8000&#10;```&#10;&#10;Após iniciar o servidor, acesse [http://localhost:8000](http://localhost:8000) no seu navegador. &#10;O arquivo `index.html` na raiz do projeto será renderizado, exibindo uma página de boas-vindas estilizada que demonstra o funcionamento do servidor web embutido do JDK 18+.&#10;&#10;---&#10;&#10;##  Executando Virtual Threads&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa o exemplo principal de Virtual Threads&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.virtualthread.Main&quot;&#10;&#10;# Ou execute a comparação de performance entre Virtual e Platform Threads&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.virtualthread.PerformanceComparison&quot;&#10;```&#10;&#10;Os exemplos demonstram como as **Virtual Threads** (Java 21+) revolucionam a programação concorrente, permitindo criar milhões de threads leves com overhead mínimo de memória. O código executa 10.000 tarefas simultaneamente, mostrando medições de performance, análise de memória e comparações com threads tradicionais. Virtual Threads são ideais para aplicações I/O intensivas como APIs REST, microserviços e operações de banco de dados.&#10;&#10;---&#10;&#10;##  Executando Sequenced Collections&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa a demonstração de Sequenced Collections&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.sequencedcollections.Main&quot;&#10;```&#10;&#10;O exemplo demonstra as **Sequenced Collections** (Java 21+), que introduzem uma API consistente para coleções que mantêm ordem de inserção. O código mostra as novas interfaces `SequencedCollection`, `SequencedSet` e `SequencedMap` com métodos como `addFirst()`, `addLast()`, `getFirst()`, `getLast()` e `reversed()`. Essa funcionalidade simplifica o trabalho com `ArrayList`, `LinkedList`, `TreeSet`, `LinkedHashMap` e outras coleções ordenadas, oferecendo uma interface uniforme sem necessidade de casting.&#10;&#10;---&#10;&#10;##  Executando Unnamed Variables &amp; Patterns&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa a demonstração de Unnamed Variables &amp; Patterns&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.unnamedvariablepatterns.Main&quot;&#10;```&#10;&#10;**Unnamed Variables &amp; Patterns** (Java 22+) introduzem o uso do underscore `_` para representar variáveis que não serão utilizadas, tornando o código mais limpo e expressivo. Esta funcionalidade elimina warnings do compilador sobre variáveis não utilizadas e comunica claramente a intenção do desenvolvedor.&#10;&#10;###  Base Teórica:&#10;&#10;**Unnamed Variables (`_`)** são uma forma de indicar explicitamente que um valor está sendo ignorado intencionalmente. Elas podem ser usadas em:&#10;&#10;- **Lambdas**: `nomes.forEach(_ -&gt; System.out.println(&quot;Processando...&quot;));`&#10;- **Exception Handling**: `catch (IOException _) { ... }`&#10;- **Pattern Matching**: `if (obj instanceof Point(int x, _)) { ... }`&#10;- **Switch Expressions**: `case Rectangle(double w, double h, _) -&gt; ...`&#10;- **Enhanced For Loops**: `for (var _ : collection) { count++; }`&#10;&#10;###  Principais Benefícios:&#10;&#10;- **Clareza de Intenção**: Indica explicitamente que um valor é ignorado propositalmente&#10;- **Código Limpo**: Elimina warnings sobre variáveis não utilizadas&#10;- **Legibilidade**: Torna o pattern matching mais fácil de entender&#10;- **Manutenibilidade**: Reduz confusão sobre parâmetros não utilizados&#10;&#10;### ✨ Exemplos Práticos:&#10;&#10;```java&#10;// Lambda: só executa ação, não usa o parâmetro&#10;nomes.forEach(_ -&gt; System.out.println(&quot;Processando...&quot;));&#10;&#10;// Exception: trata genericamente, não inspeciona detalhes&#10;catch (IOException _) { &#10;    System.out.println(&quot;Erro de I/O, continuando...&quot;); &#10;}&#10;&#10;// Record Pattern: só usa coordenada X, ignora Y&#10;if (obj instanceof Point(int x, _)) {&#10;    System.out.println(&quot;X = &quot; + x);&#10;}&#10;&#10;// Switch: ignora ângulo do triângulo, usa só base e altura&#10;case Triangle(double base, double height, _) -&gt; &#10;    (base * height) / 2;&#10;&#10;// For loop: só conta elementos, não usa o valor&#10;for (var _ : lista) {&#10;    contador++;&#10;}&#10;```&#10;&#10;**Unnamed Variables tornam o código Java mais expressivo ao comunicar claramente quando valores são intencionalmente ignorados.**&#10;" />
              <option name="updatedContent" value="# ☕ PoC - Explorando o Java 25 (e versões anteriores)&#10;&#10;Este repositório contém exemplos práticos explorando **novidades do Java 18 até o Java 25**.  &#10;A ideia é revisar recursos que surgiram nas versões recentes e experimentar, na prática, como utilizá-los em projetos do dia a dia.&#10;&#10;---&#10;&#10;##  Estrutura do Projeto&#10;&#10;- `jwebserver/` → **JWebServer** (Java 18+) - Servidor HTTP embutido no JDK.&#10;- `virtualthread/` → **Virtual Threads** (Java 21+) - Threads leves para alta concorrência.&#10;- `sequencedcollections/` → **Sequenced Collections** (Java 21+) - Coleções com ordem garantida.&#10;- `unnamedvariablepatterns/` → **Unnamed Variables &amp; Patterns** (Java 22+) - Variáveis não nomeadas.&#10;- (em breve) `records/` → Exemplos com **Records**.&#10;- (em breve) `pattern-matching/` → Exemplos de **Pattern Matching**.&#10;- (em breve) `string-templates/` → Templates de String (Preview).&#10;- (em breve) `scoped-values/` → Scoped Values (substituindo ThreadLocal).&#10;&#10;Cada diretório contém exemplos isolados e um README explicando o recurso.&#10;&#10;---&#10;&#10;##  Pré-requisitos&#10;&#10;- **Java 25+** (recomendado instalar o JDK 25 LTS ou superior).&#10;- Maven ou Gradle (dependendo do exemplo).&#10;- Git para clonar o repositório.&#10;&#10;---&#10;&#10;## ️ Executando JWebServer&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Inicia um servidor HTTP na porta 8000&#10;jwebserver --port 8000&#10;```&#10;&#10;O **JWebServer** (Java 18+) é um servidor HTTP simples embutido no JDK que elimina a necessidade de servidores externos durante desenvolvimento. Após iniciar o servidor, acesse [http://localhost:8000](http://localhost:8000) no seu navegador. O arquivo `index.html` na raiz do projeto será renderizado, exibindo uma página de boas-vindas estilizada que demonstra o funcionamento do servidor web embutido.&#10;&#10;---&#10;&#10;##  Executando Virtual Threads&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa o exemplo principal de Virtual Threads&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.virtualthread.Main&quot;&#10;&#10;# Ou execute a comparação de performance entre Virtual e Platform Threads&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.virtualthread.PerformanceComparison&quot;&#10;```&#10;&#10;**Virtual Threads** (Java 21+) revolucionam a programação concorrente, permitindo criar milhões de threads leves com overhead mínimo de memória. O código executa 10.000 tarefas simultaneamente, mostrando medições de performance, análise de memória e comparações com threads tradicionais. Virtual Threads são ideais para aplicações I/O intensivas como APIs REST, microserviços e operações de banco de dados.&#10;&#10;---&#10;&#10;##  Executando Sequenced Collections&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa a demonstração de Sequenced Collections&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.sequencedcollections.Main&quot;&#10;```&#10;&#10;**Sequenced Collections** (Java 21+) introduzem uma API consistente para coleções que mantêm ordem de inserção. O código mostra as novas interfaces `SequencedCollection`, `SequencedSet` e `SequencedMap` com métodos como `addFirst()`, `addLast()`, `getFirst()`, `getLast()` e `reversed()`. Essa funcionalidade simplifica o trabalho com `ArrayList`, `LinkedList`, `TreeSet`, `LinkedHashMap` e outras coleções ordenadas, oferecendo uma interface uniforme sem necessidade de casting.&#10;&#10;---&#10;&#10;##  Executando Unnamed Variables &amp; Patterns&#10;&#10;Entre no diretório do projeto e execute:&#10;&#10;```bash&#10;# Executa a demonstração de Unnamed Variables &amp; Patterns&#10;mvn exec:java -Dexec.mainClass=&quot;io.github.wesleyosantos91.unnamedvariablepatterns.Main&quot;&#10;```&#10;&#10;**Unnamed Variables &amp; Patterns** (Java 22+) introduzem o uso do underscore `_` para representar variáveis que não serão utilizadas, tornando o código mais limpo e expressivo. O código demonstra uso em lambdas (`nomes.forEach(_ -&gt; ...)`), exception handling (`catch (IOException _)`), pattern matching (`if (obj instanceof Point(int x, _))`) e switch expressions (`case Triangle(_, _, angle)`). Esta funcionalidade elimina warnings do compilador sobre variáveis não utilizadas e comunica claramente a intenção do desenvolvedor.&#10;&#10;###  Base Teórica:&#10;&#10;**Unnamed Variables (`_`)** são uma forma de indicar explicitamente que um valor está sendo ignorado intencionalmente. Elas podem ser usadas em:&#10;&#10;- **Lambdas**: `nomes.forEach(_ -&gt; System.out.println(&quot;Processando...&quot;));`&#10;- **Exception Handling**: `catch (IOException _) { ... }`&#10;- **Pattern Matching**: `if (obj instanceof Point(int x, _)) { ... }`&#10;- **Switch Expressions**: `case Rectangle(double w, double h, _) -&gt; ...`&#10;- **Enhanced For Loops**: `for (var _ : collection) { count++; }`&#10;&#10;###  Principais Benefícios:&#10;&#10;- **Clareza de Intenção**: Indica explicitamente que um valor é ignorado propositalmente&#10;- **Código Limpo**: Elimina warnings sobre variáveis não utilizadas&#10;- **Legibilidade**: Torna o pattern matching mais fácil de entender&#10;- **Manutenibilidade**: Reduz confusão sobre parâmetros não utilizados&#10;&#10;### ✨ Exemplos Práticos:&#10;&#10;```java&#10;// Lambda: só executa ação, não usa o parâmetro&#10;nomes.forEach(_ -&gt; System.out.println(&quot;Processando...&quot;));&#10;&#10;// Exception: trata genericamente, não inspeciona detalhes&#10;catch (IOException _) { &#10;    System.out.println(&quot;Erro de I/O, continuando...&quot;); &#10;}&#10;&#10;// Record Pattern: só usa coordenada X, ignora Y&#10;if (obj instanceof Point(int x, _)) {&#10;    System.out.println(&quot;X = &quot; + x);&#10;}&#10;&#10;// Switch: ignora ângulo do triângulo, usa só base e altura&#10;case Triangle(double base, double height, _) -&gt; &#10;    (base * height) / 2;&#10;&#10;// For loop: só conta elementos, não usa o valor&#10;for (var _ : lista) {&#10;    contador++;&#10;}&#10;```&#10;&#10;**Unnamed Variables tornam o código Java mais expressivo ao comunicar claramente quando valores são intencionalmente ignorados.**" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>